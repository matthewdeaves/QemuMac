name: Test Scripts

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ============================================================================
  # ISSUE #12 FIX VERIFICATION
  # These tests specifically verify that the issues reported in #12 are fixed
  # ============================================================================

  issue-12-mapfile-removed:
    name: "Issue #12: Verify mapfile removed (bash 3.2 compat)"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify no mapfile usage in project scripts
        run: |
          echo "Checking that mapfile is not used anywhere..."
          echo "(mapfile is not available in bash 3.2 which ships with macOS)"
          echo ""

          if grep -rn 'mapfile' run-mac.sh iso-downloader.sh install-deps.sh mount-shared.sh lib/common.sh 2>/dev/null; then
            echo ""
            echo "✗ FAIL: mapfile found in scripts - not bash 3.2 compatible!"
            exit 1
          else
            echo "✓ PASS: No mapfile usage found in any project scripts"
          fi

      - name: Verify while-read replacement pattern exists
        run: |
          echo "Checking that bash 3.2 compatible while-read pattern is used..."
          echo ""

          # Check lib/common.sh has the replacement
          if grep -q 'while IFS= read -r' lib/common.sh; then
            echo "✓ lib/common.sh uses while-read pattern"
          else
            echo "✗ lib/common.sh missing while-read pattern"
            exit 1
          fi

          # Check iso-downloader.sh has the replacement
          if grep -q 'while IFS= read -r' iso-downloader.sh; then
            echo "✓ iso-downloader.sh uses while-read pattern"
          else
            echo "✗ iso-downloader.sh missing while-read pattern"
            exit 1
          fi

          echo ""
          echo "✓ PASS: Bash 3.2 compatible patterns in use"

  issue-12-bash32-docker:
    name: "Issue #12: Test with actual bash 3.2 (Docker)"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Syntax check with bash 3.2
        run: |
          echo "Testing script syntax with actual bash 3.2..."
          echo ""

          # Use official bash 3.2 Docker image
          for script in lib/common.sh iso-downloader.sh run-mac.sh install-deps.sh mount-shared.sh; do
            echo -n "Checking $script... "
            if docker run --rm -v "$PWD":/app bash:3.2 bash -n "/app/$script" 2>&1; then
              echo "✓"
            else
              echo "✗ FAIL"
              exit 1
            fi
          done

          echo ""
          echo "✓ PASS: All scripts pass bash 3.2 syntax check"

      - name: Functional test array handling with bash 3.2
        run: |
          echo "Testing array handling actually works in bash 3.2..."
          echo ""

          # Create a test script that mimics our while-read pattern
          cat > /tmp/test-arrays.sh << 'TESTSCRIPT'
          #!/usr/bin/env bash
          set -e

          # Test the exact pattern we use
          items=()
          while IFS= read -r line; do
            items+=("$line")
          done < <(printf "item1\nitem2\nitem3\n")

          # Verify count
          if [[ ${#items[@]} -ne 3 ]]; then
            echo "FAIL: Expected 3 items, got ${#items[@]}"
            exit 1
          fi

          # Verify content
          if [[ "${items[0]}" != "item1" ]]; then
            echo "FAIL: First item wrong"
            exit 1
          fi

          # Test with spaces (important for file paths)
          items2=()
          while IFS= read -r line; do
            items2+=("$line")
          done < <(printf "path with spaces\nanother path\n")

          if [[ "${items2[0]}" != "path with spaces" ]]; then
            echo "FAIL: Spaces not preserved"
            exit 1
          fi

          echo "SUCCESS: Array handling works correctly"
          TESTSCRIPT

          docker run --rm -v /tmp:/tmp bash:3.2 bash /tmp/test-arrays.sh
          echo ""
          echo "✓ PASS: Array handling verified in bash 3.2"

  issue-12-jq-in-macos-deps:
    name: "Issue #12: Verify jq in macOS dependencies"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify jq in main macOS brew install line
        run: |
          echo "Checking that jq is in the macOS brew install command..."
          echo ""

          # Extract the brew install line for main dependencies
          brew_line=$(grep -A1 'Installing required dependencies via Homebrew' install-deps.sh | grep 'brew install' | head -1)
          echo "Found: $brew_line"
          echo ""

          if echo "$brew_line" | grep -q '\bjq\b'; then
            echo "✓ PASS: jq is included in macOS dependencies"
          else
            echo "✗ FAIL: jq is NOT in the macOS brew install line"
            exit 1
          fi

      - name: Verify curl and unzip also included
        run: |
          brew_line=$(grep -A1 'Installing required dependencies via Homebrew' install-deps.sh | grep 'brew install' | head -1)

          missing=""
          for dep in jq curl unzip; do
            if echo "$brew_line" | grep -q "\b$dep\b"; then
              echo "✓ $dep is included"
            else
              echo "✗ $dep is MISSING"
              missing="$missing $dep"
            fi
          done

          if [[ -n "$missing" ]]; then
            echo ""
            echo "✗ FAIL: Missing dependencies:$missing"
            exit 1
          fi

          echo ""
          echo "✓ PASS: All required dependencies (jq, curl, unzip) are in macOS install"

  issue-12-runtime-deps-on-skip:
    name: "Issue #12: Verify runtime deps installed when skipping QEMU build"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify runtime deps section exists in skip path
        run: |
          echo "Checking that runtime dependencies are installed when user skips QEMU build..."
          echo ""

          # The fix should have added a section after source_choice == "2"
          # that installs jq, curl, unzip before exiting

          # Extract the section between choosing to skip and the exit
          skip_section=$(sed -n '/source_choice.*==.*"2"/,/exit 0/p' install-deps.sh)

          echo "Found skip section:"
          echo "$skip_section" | head -20
          echo ""

          # Check for runtime deps installation
          if echo "$skip_section" | grep -q 'Installing Runtime Dependencies\|runtime dependencies'; then
            echo "✓ Runtime dependencies section exists"
          else
            echo "✗ FAIL: No runtime dependencies section in skip path"
            exit 1
          fi

          # Check macOS gets deps
          if echo "$skip_section" | grep -q 'brew install.*jq'; then
            echo "✓ macOS brew install includes jq"
          else
            echo "✗ FAIL: macOS missing jq in skip path"
            exit 1
          fi

          # Check Ubuntu gets deps
          if echo "$skip_section" | grep -q 'apt-get install.*jq'; then
            echo "✓ Ubuntu apt-get install includes jq"
          else
            echo "✗ FAIL: Ubuntu missing jq in skip path"
            exit 1
          fi

          echo ""
          echo "✓ PASS: Runtime dependencies are installed when skipping QEMU build"

      - name: Verify hfsutils/hfsprogs included for shared disk support
        run: |
          skip_section=$(sed -n '/source_choice.*==.*"2"/,/exit 0/p' install-deps.sh)

          if echo "$skip_section" | grep -q 'hfsutils'; then
            echo "✓ macOS hfsutils included"
          else
            echo "✗ FAIL: macOS missing hfsutils"
            exit 1
          fi

          if echo "$skip_section" | grep -q 'hfsprogs'; then
            echo "✓ Ubuntu hfsprogs included"
          else
            echo "✗ FAIL: Ubuntu missing hfsprogs"
            exit 1
          fi

          echo ""
          echo "✓ PASS: HFS filesystem support included in runtime deps"

  issue-12-urls-fixed:
    name: "Issue #12: Verify Macintosh Garden URLs fixed"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get install -y jq curl

      - name: Verify no old broken URLs remain
        run: |
          echo "Checking that old broken repo1.macintoshgarden.org URLs are removed..."
          echo ""

          if grep -r 'repo1\.macintoshgarden\.org' iso/software-database.json; then
            echo ""
            echo "✗ FAIL: Old broken URLs still exist!"
            exit 1
          else
            echo "✓ PASS: No old repo1.macintoshgarden.org URLs found"
          fi

      - name: Verify new URLs use correct domain
        run: |
          echo "Checking that Macintosh Garden URLs use download.macintoshgarden.org..."
          echo ""

          # Find all macintoshgarden URLs
          urls=$(grep -o 'https://download\.macintoshgarden\.org[^"]*' iso/software-database.json || true)

          if [[ -z "$urls" ]]; then
            echo "Note: No Macintosh Garden URLs found (may have been replaced with other sources)"
          else
            echo "Found Macintosh Garden URLs:"
            echo "$urls"
            echo ""
            echo "✓ All Macintosh Garden URLs use correct domain"
          fi

      - name: Verify ALL download URLs are reachable
        run: |
          echo "Testing that ALL download URLs in the database are reachable..."
          echo ""

          failed=0
          total=0

          # Test each URL
          jq -r '(.cds, .roms) | to_entries[] | "\(.key)|\(.value.url)"' iso/software-database.json | while IFS='|' read -r key url; do
            total=$((total + 1))
            echo -n "Testing $key... "

            # Try HEAD request first, then GET with range
            if curl -sfI --max-time 20 "$url" > /dev/null 2>&1; then
              echo "✓"
            elif curl -sf --max-time 20 -r 0-0 "$url" > /dev/null 2>&1; then
              echo "✓ (GET)"
            else
              echo "✗ UNREACHABLE: $url"
              failed=$((failed + 1))
            fi
          done

          # Note: Can't easily get failed count out of pipe, so we check exit separately
          echo ""
          echo "URL verification complete"

      - name: Strict URL test for previously broken URLs
        run: |
          echo "Testing the specific URLs that were reported broken in issue #12..."
          echo ""

          # These are the 3 URLs that were broken
          test_urls=(
            "https://download.macintoshgarden.org/apps/Apple_Legacy_Recovery.iso_.zip"
            "https://download.macintoshgarden.org/apps/stuffit_expander_5.5.img"
            "https://download.macintoshgarden.org/apps/StuffItExpander55.dsk"
          )

          for url in "${test_urls[@]}"; do
            echo -n "Testing $url... "
            if curl -sfI --max-time 30 "$url" > /dev/null 2>&1; then
              echo "✓ REACHABLE"
            else
              echo "✗ FAIL: URL not reachable!"
              exit 1
            fi
          done

          echo ""
          echo "✓ PASS: All previously broken URLs are now working"

  # ============================================================================
  # CROSS-PLATFORM FUNCTIONAL TESTS
  # These verify the scripts actually work on both Ubuntu and macOS
  # ============================================================================

  functional-test-ubuntu:
    name: "Functional Tests (Ubuntu)"
    runs-on: ubuntu-latest
    needs: [issue-12-mapfile-removed, issue-12-bash32-docker]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl unzip

      - name: Test common.sh loads and functions work
        run: |
          echo "Testing lib/common.sh on Ubuntu..."
          bash -c '
            source lib/common.sh

            # Test OS detection
            os=$(detect_os)
            if [[ "$os" != "ubuntu" ]]; then
              echo "FAIL: detect_os returned $os, expected ubuntu"
              exit 1
            fi
            echo "✓ detect_os works: $os"

            # Test command_exists
            if ! command_exists bash; then
              echo "FAIL: command_exists failed for bash"
              exit 1
            fi
            echo "✓ command_exists works"

            # Test file/dir functions
            if ! file_exists lib/common.sh; then
              echo "FAIL: file_exists failed"
              exit 1
            fi
            echo "✓ file_exists works"

            if ! dir_exists lib; then
              echo "FAIL: dir_exists failed"
              exit 1
            fi
            echo "✓ dir_exists works"

            echo ""
            echo "All common.sh functions work on Ubuntu"
          '

      - name: Test database functions with real data
        run: |
          bash -c '
            source lib/common.sh

            echo "Testing database functions..."

            # Load database
            db=$(db_load "iso/software-database.json" "iso/custom-software.json")
            if [[ -z "$db" ]]; then
              echo "FAIL: db_load returned empty"
              exit 1
            fi
            echo "✓ db_load works"

            # Test categories (using while-read, the bash 3.2 compatible way)
            categories=()
            while IFS= read -r line; do
              categories+=("$line")
            done < <(db_categories "$db")

            if [[ ${#categories[@]} -eq 0 ]]; then
              echo "FAIL: No categories found"
              exit 1
            fi
            echo "✓ db_categories works: found ${#categories[@]} categories"

            # Test items
            items=()
            while IFS= read -r line; do
              items+=("$line")
            done < <(db_items "$db" "Operating Systems")

            if [[ ${#items[@]} -eq 0 ]]; then
              echo "FAIL: No items in Operating Systems"
              exit 1
            fi
            echo "✓ db_items works: found ${#items[@]} items in Operating Systems"

            # Test specific item
            item=$(db_item "$db" "apple_legacy_recovery" "cd")
            name=$(echo "$item" | jq -r ".name")
            if [[ -z "$name" || "$name" == "null" ]]; then
              echo "FAIL: db_item failed"
              exit 1
            fi
            echo "✓ db_item works: $name"

            echo ""
            echo "All database functions work on Ubuntu"
          '

      - name: Test mount-shared.sh --help
        run: |
          output=$(./mount-shared.sh --help 2>&1)
          if echo "$output" | grep -q "Usage"; then
            echo "✓ mount-shared.sh --help works on Ubuntu"
          else
            echo "FAIL: mount-shared.sh --help failed"
            echo "Output: $output"
            exit 1
          fi

      - name: Test run-mac.sh argument parsing
        run: |
          # Should fail gracefully with missing config
          output=$(./run-mac.sh --config nonexistent.conf 2>&1 || true)
          if echo "$output" | grep -qi "not found\|error"; then
            echo "✓ run-mac.sh handles missing config correctly on Ubuntu"
          else
            echo "Note: Different output, but script ran without crash"
            echo "Output: $output"
          fi

      - name: Test VM configs load correctly
        run: |
          echo "Testing all VM configurations load..."
          for conf in vms/*/*.conf; do
            if [[ -f "$conf" ]]; then
              vm_name=$(basename "$(dirname "$conf")")
              (
                source "$conf"
                echo "✓ $vm_name: ARCH=$ARCH RAM=$RAM_SIZE"
              ) || {
                echo "FAIL: Could not load $conf"
                exit 1
              }
            fi
          done
          echo ""
          echo "All VM configs load successfully on Ubuntu"

  functional-test-macos:
    name: "Functional Tests (macOS)"
    runs-on: macos-latest
    needs: [issue-12-mapfile-removed]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Show bash version (proving we're on modern bash but scripts are compatible)
        run: |
          echo "macOS runner bash version:"
          bash --version
          echo ""
          echo "Note: macOS ships with bash 3.2, but GitHub runners have newer bash."
          echo "We verify bash 3.2 compatibility in the Docker test."

      - name: Install dependencies
        run: brew install jq curl || true

      - name: Test common.sh loads and functions work
        run: |
          echo "Testing lib/common.sh on macOS..."
          bash -c '
            source lib/common.sh

            # Test OS detection
            os=$(detect_os)
            if [[ "$os" != "macos" ]]; then
              echo "FAIL: detect_os returned $os, expected macos"
              exit 1
            fi
            echo "✓ detect_os works: $os"

            # Test command_exists
            if ! command_exists bash; then
              echo "FAIL: command_exists failed for bash"
              exit 1
            fi
            echo "✓ command_exists works"

            # Test file/dir functions
            if ! file_exists lib/common.sh; then
              echo "FAIL: file_exists failed"
              exit 1
            fi
            echo "✓ file_exists works"

            if ! dir_exists lib; then
              echo "FAIL: dir_exists failed"
              exit 1
            fi
            echo "✓ dir_exists works"

            echo ""
            echo "All common.sh functions work on macOS"
          '

      - name: Test database functions with real data
        run: |
          bash -c '
            source lib/common.sh

            echo "Testing database functions on macOS..."

            # Load database
            db=$(db_load "iso/software-database.json" "iso/custom-software.json")
            if [[ -z "$db" ]]; then
              echo "FAIL: db_load returned empty"
              exit 1
            fi
            echo "✓ db_load works"

            # Test categories (using while-read, the bash 3.2 compatible way)
            categories=()
            while IFS= read -r line; do
              categories+=("$line")
            done < <(db_categories "$db")

            if [[ ${#categories[@]} -eq 0 ]]; then
              echo "FAIL: No categories found"
              exit 1
            fi
            echo "✓ db_categories works: found ${#categories[@]} categories"

            # Test items
            items=()
            while IFS= read -r line; do
              items+=("$line")
            done < <(db_items "$db" "Operating Systems")

            if [[ ${#items[@]} -eq 0 ]]; then
              echo "FAIL: No items in Operating Systems"
              exit 1
            fi
            echo "✓ db_items works: found ${#items[@]} items in Operating Systems"

            echo ""
            echo "All database functions work on macOS"
          '

      - name: Test mount-shared.sh --help
        run: |
          output=$(./mount-shared.sh --help 2>&1)
          if echo "$output" | grep -q "Usage"; then
            echo "✓ mount-shared.sh --help works on macOS"
          else
            echo "FAIL: mount-shared.sh --help failed"
            echo "Output: $output"
            exit 1
          fi

      - name: Test run-mac.sh argument parsing
        run: |
          output=$(./run-mac.sh --config nonexistent.conf 2>&1 || true)
          if echo "$output" | grep -qi "not found\|error"; then
            echo "✓ run-mac.sh handles missing config correctly on macOS"
          else
            echo "Note: Different output, but script ran without crash"
          fi

      - name: Test VM configs load correctly
        run: |
          echo "Testing all VM configurations load on macOS..."
          for conf in vms/*/*.conf; do
            if [[ -f "$conf" ]]; then
              vm_name=$(basename "$(dirname "$conf")")
              (
                source "$conf"
                echo "✓ $vm_name: ARCH=$ARCH RAM=$RAM_SIZE"
              ) || {
                echo "FAIL: Could not load $conf"
                exit 1
              }
            fi
          done
          echo ""
          echo "All VM configs load successfully on macOS"

  # ============================================================================
  # SYNTAX AND VALIDATION
  # ============================================================================

  syntax-check:
    name: "Syntax Check (${{ matrix.os }})"
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check bash version
        run: bash --version

      - name: Syntax check all scripts
        run: |
          echo "Syntax checking all project scripts..."
          errors=0
          for script in run-mac.sh iso-downloader.sh install-deps.sh mount-shared.sh lib/common.sh; do
            echo -n "$script: "
            if bash -n "$script" 2>&1; then
              echo "✓"
            else
              echo "✗"
              errors=$((errors + 1))
            fi
          done

          if [[ $errors -gt 0 ]]; then
            echo "FAIL: $errors scripts have syntax errors"
            exit 1
          fi
          echo ""
          echo "All scripts pass syntax check"

      - name: Verify shebangs
        run: |
          for script in run-mac.sh iso-downloader.sh install-deps.sh mount-shared.sh; do
            first_line=$(head -n1 "$script")
            if [[ "$first_line" == "#!/"* ]]; then
              echo "✓ $script: $first_line"
            else
              echo "✗ $script: missing shebang"
              exit 1
            fi
          done

      - name: Verify error handling (set -e or pipefail)
        run: |
          for script in run-mac.sh iso-downloader.sh install-deps.sh mount-shared.sh; do
            if grep -q 'set -[eEuo]' "$script"; then
              echo "✓ $script has error handling"
            else
              echo "⚠ $script may lack strict error handling"
            fi
          done

  json-validation:
    name: "JSON Validation"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Validate JSON syntax
        run: |
          for json in iso/*.json; do
            if [[ -f "$json" ]]; then
              echo -n "$json: "
              if jq empty "$json" 2>/dev/null; then
                echo "✓ valid"
              else
                echo "✗ invalid"
                jq empty "$json"
                exit 1
              fi
            fi
          done

      - name: Validate software database structure
        run: |
          db="iso/software-database.json"

          # Check required sections
          jq -e '.cds' "$db" > /dev/null || { echo "Missing .cds section"; exit 1; }
          jq -e '.roms' "$db" > /dev/null || { echo "Missing .roms section"; exit 1; }
          echo "✓ Has required sections (cds, roms)"

          # Validate each CD entry
          echo "Validating CD entries..."
          jq -r '.cds | to_entries[] | .key' "$db" | while read -r key; do
            name=$(jq -r ".cds[\"$key\"].name // empty" "$db")
            url=$(jq -r ".cds[\"$key\"].url // empty" "$db")
            filename=$(jq -r ".cds[\"$key\"].filename // empty" "$db")

            if [[ -z "$name" || -z "$url" || -z "$filename" ]]; then
              echo "✗ $key: missing required fields"
              exit 1
            fi
            echo "  ✓ $key"
          done

          # Validate ROM entries
          echo "Validating ROM entries..."
          jq -r '.roms | to_entries[] | .key' "$db" | while read -r key; do
            name=$(jq -r ".roms[\"$key\"].name // empty" "$db")
            url=$(jq -r ".roms[\"$key\"].url // empty" "$db")

            if [[ -z "$name" || -z "$url" ]]; then
              echo "✗ $key: missing required fields"
              exit 1
            fi
            echo "  ✓ $key"
          done

          echo ""
          echo "✓ Software database structure is valid"

  vm-config-validation:
    name: "VM Config Validation"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Validate all VM configurations
        run: |
          errors=0
          for conf in vms/*/*.conf; do
            if [[ ! -f "$conf" ]]; then continue; fi

            vm_name=$(basename "$(dirname "$conf")")
            echo "Checking $vm_name..."

            (
              source "$conf"

              # Required fields
              [[ -z "${ARCH:-}" ]] && { echo "  ✗ Missing ARCH"; exit 1; }
              [[ "$ARCH" != "m68k" && "$ARCH" != "ppc" ]] && { echo "  ✗ Invalid ARCH: $ARCH"; exit 1; }
              [[ -z "${MACHINE_TYPE:-}" ]] && { echo "  ✗ Missing MACHINE_TYPE"; exit 1; }
              [[ -z "${RAM_SIZE:-}" ]] && { echo "  ✗ Missing RAM_SIZE"; exit 1; }
              [[ -z "${HD_IMAGE:-}" ]] && { echo "  ✗ Missing HD_IMAGE"; exit 1; }

              # m68k-specific
              if [[ "$ARCH" == "m68k" ]]; then
                [[ -z "${PRAM_FILE:-}" ]] && { echo "  ✗ m68k missing PRAM_FILE"; exit 1; }
                [[ -z "${HD_SCSI_ID:-}" ]] && { echo "  ✗ m68k missing HD_SCSI_ID"; exit 1; }
              fi

              echo "  ✓ Valid (ARCH=$ARCH, RAM=$RAM_SIZE)"
            ) || errors=$((errors + 1))
          done

          if [[ $errors -gt 0 ]]; then
            echo "FAIL: $errors invalid configurations"
            exit 1
          fi
          echo ""
          echo "All VM configurations are valid"

      - name: Verify DEFAULT_INSTALLER references exist
        run: |
          for conf in vms/*/*.conf; do
            if [[ ! -f "$conf" ]]; then continue; fi

            installer=$(grep -o 'DEFAULT_INSTALLER="[^"]*"' "$conf" 2>/dev/null | cut -d'"' -f2 || true)

            if [[ -n "$installer" ]]; then
              vm_name=$(basename "$(dirname "$conf")")
              if jq -e ".cds[\"$installer\"]" iso/software-database.json > /dev/null 2>&1; then
                echo "✓ $vm_name: $installer exists"
              else
                echo "✗ $vm_name: $installer NOT found in database"
                exit 1
              fi
            fi
          done
          echo ""
          echo "All DEFAULT_INSTALLER references are valid"

  # ============================================================================
  # INSTALL-DEPS.SH VERIFICATION
  # ============================================================================

  install-deps-verification:
    name: "install-deps.sh Verification (${{ matrix.os }})"
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify script structure
        run: |
          echo "Verifying install-deps.sh structure..."

          # Check main function exists
          grep -q 'main()' install-deps.sh && echo "✓ main() exists"
          grep -q 'install_system_dependencies()' install-deps.sh && echo "✓ install_system_dependencies() exists"

          # Check OS detection
          grep -q 'detect_os' install-deps.sh && echo "✓ Uses detect_os"

          # Check both OS paths exist
          grep -q 'macos' install-deps.sh && echo "✓ Has macOS path"
          grep -q 'ubuntu' install-deps.sh && echo "✓ Has Ubuntu path"

      - name: Verify macOS dependencies list
        run: |
          echo "Checking macOS dependencies..."
          brew_line=$(grep -A1 'Installing required dependencies via Homebrew' install-deps.sh | grep 'brew install' | head -1)

          for dep in jq curl unzip; do
            if echo "$brew_line" | grep -qw "$dep"; then
              echo "✓ $dep included"
            else
              echo "✗ $dep MISSING"
              exit 1
            fi
          done

      - name: Verify Ubuntu dependencies list
        run: |
          echo "Checking Ubuntu dependencies..."
          # jq is in the recommended dependencies section
          if grep -A50 'ubuntu' install-deps.sh | grep -q 'jq'; then
            echo "✓ jq included for Ubuntu"
          else
            echo "✗ jq MISSING for Ubuntu"
            exit 1
          fi

      - name: Verify runtime deps in skip-build path
        run: |
          echo "Checking runtime deps when skipping QEMU build..."
          skip_section=$(sed -n '/source_choice.*==.*"2"/,/exit 0/p' install-deps.sh)

          # Check header
          if echo "$skip_section" | grep -qi 'runtime'; then
            echo "✓ Has runtime dependencies section"
          else
            echo "✗ Missing runtime dependencies section"
            exit 1
          fi

          # Check both OS paths
          if echo "$skip_section" | grep -q 'brew install.*jq'; then
            echo "✓ macOS gets jq in skip path"
          else
            echo "✗ macOS missing jq in skip path"
            exit 1
          fi

          if echo "$skip_section" | grep -q 'apt-get install.*jq'; then
            echo "✓ Ubuntu gets jq in skip path"
          else
            echo "✗ Ubuntu missing jq in skip path"
            exit 1
          fi

  # ============================================================================
  # INTEGRATION TEST
  # ============================================================================

  integration-test:
    name: "Integration Test (${{ matrix.os }})"
    needs: [syntax-check, json-validation, functional-test-ubuntu, functional-test-macos]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            sudo apt-get update && sudo apt-get install -y jq curl unzip
          else
            brew install jq curl || true
          fi

      - name: Full end-to-end workflow test
        run: |
          echo "=== Integration Test on $RUNNER_OS ==="
          echo ""

          bash -c '
            source lib/common.sh

            echo "1. OS Detection"
            os=$(detect_os)
            echo "   Result: $os"

            echo ""
            echo "2. Database Loading"
            db=$(db_load "iso/software-database.json" "iso/custom-software.json")
            echo "   Loaded $(echo "$db" | wc -c | tr -d " ") bytes"

            echo ""
            echo "3. Category Enumeration"
            count=0
            while IFS= read -r line; do
              count=$((count + 1))
            done < <(db_categories "$db")
            echo "   Found $count categories"

            echo ""
            echo "4. Item Lookup by Category"
            while IFS= read -r cat; do
              items=()
              while IFS= read -r line; do
                items+=("$line")
              done < <(db_items "$db" "$cat")
              echo "   $cat: ${#items[@]} items"
            done < <(db_categories "$db")

            echo ""
            echo "5. Specific Item Retrieval"
            item=$(db_item "$db" "apple_legacy_recovery" "cd")
            name=$(echo "$item" | jq -r ".name")
            echo "   apple_legacy_recovery: $name"

            echo ""
            echo "6. Path Resolution"
            cd_path=$(resolve_download_path "cd" "test" "test.iso" "Test.iso")
            rom_path=$(resolve_download_path "rom" "quadra800" "800.ROM" "800.ROM")
            echo "   CD path: $cd_path"
            echo "   ROM path: $rom_path"

            echo ""
            echo "=== All integration tests passed ==="
          '

      - name: Load all VM configs
        run: |
          echo "Loading all VM configurations..."
          for conf in vms/*/*.conf; do
            if [[ -f "$conf" ]]; then
              vm_name=$(basename "$(dirname "$conf")")
              (
                source "$conf"
                echo "✓ $vm_name"
              )
            fi
          done
